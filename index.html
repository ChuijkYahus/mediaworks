<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <meta content="The Hex Book, all in one place." name="description">
    <meta content="petrak@, Alwinfy" name="author">
    <link href="icon.png" rel="icon">

    <title>Hex Book</title>

    <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css"
          integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.3.0/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        summary {
            display: list-item;
        }

        details.spell-collapsible {
            display: inline-block;
            border: 1px solid #aaa;
            border-radius: 4px;
            padding: .5em .5em 0;
            margin-bottom: .5em;
        }

        summary.collapse-spell {
            font-weight: bold;
            margin: -.5em -.5em 0;
            padding: .5em;
        }

        details.spell-collapsible[open] {
            padding: .5em;
        }

        details[open] summary.collapse-spell {
            border-bottom: 1px solid #aaa;
            margin-bottom: .5em;
        }

        details .collapse-spell::before {
            content: "Click to show spell";
        }

        details[open] .collapse-spell::before {
            content: "Click to hide spell";
        }

        blockquote.crafting-info {
            font-size: inherit;
        }

        a.toggle-link {
            margin-left: 0.5em;
        }

        a.permalink {
            margin-left: 0.5em;
        }

        a.permalink:hover {
            color: lightgray;
        }

        p {
            margin: 0.5ex 0;
        }

        p.fake-li {
            margin: 0;
        }

        p.fake-li::before {
            content: "\2022";
            margin: 1ex;
        }

        .linkout::before {
            content: "Link: ";
        }

        p.todo-note {
            font-style: italic;
            color: lightgray;
        }

        .obfuscated {
            filter: blur(1em);
        }

        .spoilered {
            filter: blur(1ex);
            -moz-transition: filter 0.04s linear;
        }

        .spoilered:hover {
            filter: blur(0.5ex);
        }

        .spoilered.unspoilered {
            filter: blur(0);
        }

        canvas.spell-viz {
            --dot-color: #777f;
            --start-dot-color: #f009;
            --moving-dot-color: #0fa9;

            --path-color: darkgray;
            --visited-path-color: #0c8;

            --dot-scale: 0.0625;
            --moving-dot-scale: 0.125;
            --line-scale: 0.08333;
            --pausetext-scale: 0.5;
        }

    </style>
    <noscript>
        <style>
            /* for accessibility */
            .spoilered {
                filter: none !important;
            }

        </style>
    </noscript>
    <script>
        "use strict";
        const speeds = [0, 0.25, 0.5, 1, 2, 4];
        const scrollThreshold = 100;
        const rfaQueue = [];

        function startAngle(str) {
            switch (str) {
                case "east":
                    return 0;
                case "north_east":
                    return 1;
                case "north_west":
                    return 2;
                case "west":
                    return 3;
                case "south_west":
                    return 4;
                case "south_east":
                    return 5;
                default:
                    return 0;
            }
        }

        function offsetAngle(str) {
            switch (str) {
                case "w":
                    return 0;
                case "q":
                    return 1;
                case "a":
                    return 2;
                case "s":
                    return 3;
                case "d":
                    return 4;
                case "e":
                    return 5;
                default:
                    return -1;
            }
        }

        function initializeElem(canvas) {
            const str = canvas.dataset.string;
            let angle = startAngle(canvas.dataset.start);
            const perWorld = canvas.dataset.perWorld === "True";

            // build geometry
            const points = [[0, 0]];
            let lastPoint = points[0];
            let minPoint = lastPoint, maxPoint = lastPoint;
            for (const ch of "w" + str) {
                const addAngle = offsetAngle(ch);
                if (addAngle < 0) continue;
                angle = (angle + addAngle) % 6;
                const trueAngle = Math.PI / 3 * angle;

                const [lx, ly] = lastPoint;
                const newPoint = [lx + Math.cos(trueAngle), ly - Math.sin(trueAngle)];

                points.push(newPoint);
                lastPoint = newPoint;

                const [mix, miy] = minPoint;
                minPoint = [Math.min(mix, newPoint[0]), Math.min(miy, newPoint[1])];
                const [max, may] = maxPoint;
                maxPoint = [Math.max(max, newPoint[0]), Math.max(may, newPoint[1])];
            }
            const size = Math.min(canvas.width, canvas.height) * 0.8;
            const scale = size / Math.max(3, Math.max(maxPoint[1] - minPoint[1], maxPoint[0] - minPoint[0]));
            const center = [(minPoint[0] + maxPoint[0]) * 0.5, (minPoint[1] + maxPoint[1]) * 0.5];
            const truePoints = points.map(p => [canvas.width * 0.5 + scale * (p[0] - center[0]), canvas.height * 0.5 + scale * (p[1] - center[1])]);
            let uniqPoints = [];
            l1: for (const point of truePoints) {
                for (const pt of uniqPoints) {
                    if (Math.abs(point[0] - pt[0]) < 0.00001 && Math.abs(point[1] - pt[1]) < 0.00001) {
                        continue l1;
                    }
                }
                uniqPoints.push(point);
            }

            // rendering code
            const speed = 0.0025;
            const context = canvas.getContext("2d");
            const negaProgress = -3;
            let progress = 0;
            let scrollTimeout = 1e309;
            let speedLevel = 3;
            let speedIncrement = 0;

            function speedScale() {
                return speeds[speedLevel];
            }

            const style = getComputedStyle(canvas);
            const getProp = n => style.getPropertyValue(n);

            const tick = dt => {
                scrollTimeout += dt;
                if (canvas.offsetParent === null) return;

                const strokeStyle = getProp("--path-color");
                const strokeVisitedStyle = getProp("--visited-path-color");

                const startDotStyle = getProp("--start-dot-color");
                const dotStyle = getProp("--dot-color");
                const movDotStyle = getProp("--moving-dot-color");

                const strokeWidth = scale * +getProp("--line-scale");
                const dotRadius = scale * +getProp("--dot-scale");
                const movDotRadius = scale * +getProp("--moving-dot-scale");
                const pauseScale = scale * +getProp("--pausetext-scale");


                if (!perWorld) {
                    progress += speed * dt * (progress > 0 ? speedScale() : Math.sqrt(speedScale()));
                }
                if (progress >= truePoints.length - 1) {
                    progress = negaProgress;
                }
                let ix = Math.floor(progress), frac = progress - ix, core = null, fadeColor = 0;
                if (ix < 0) {
                    const rawFade = 2 * progress / negaProgress - 1;
                    fadeColor = 1 - Math.abs(rawFade);
                    context.strokeStyle = rawFade > 0 ? strokeVisitedStyle : strokeStyle;
                    ix = rawFade > 0 ? truePoints.length - 2 : 0;
                    frac = +(rawFade > 0);
                } else {
                    context.strokeStyle = strokeVisitedStyle;
                }

                const [lx, ly] = truePoints[ix];
                const [rx, ry] = truePoints[ix + 1];
                core = [lx + (rx - lx) * frac, ly + (ry - ly) * frac];


                context.clearRect(0, 0, canvas.width, canvas.height);
                context.beginPath();
                context.lineWidth = strokeWidth;
                context.moveTo(truePoints[0][0], truePoints[0][1]);
                for (let i = 1; i < ix + 1; i++) {
                    context.lineTo(truePoints[i][0], truePoints[i][1]);
                }
                context.lineTo(core[0], core[1]);
                context.stroke();
                context.beginPath();
                context.strokeStyle = strokeStyle;
                context.moveTo(core[0], core[1]);
                for (let i = ix + 1; i < truePoints.length; i++) {
                    context.lineTo(truePoints[i][0], truePoints[i][1]);
                }
                context.stroke();

                for (let i = 0; i < uniqPoints.length; i++) {
                    context.beginPath();
                    context.fillStyle = (i == 0 && !perWorld) ? startDotStyle : dotStyle;
                    const radius = (i == 0 && !perWorld) ? movDotRadius : dotRadius;
                    context.arc(uniqPoints[i][0], uniqPoints[i][1], radius, 0, 2 * Math.PI);
                    context.fill();
                }

                if (!perWorld) {
                    context.beginPath();
                    context.fillStyle = movDotStyle;
                    context.arc(core[0], core[1], movDotRadius, 0, 2 * Math.PI);
                    context.fill();
                }
                if (fadeColor) {
                    context.fillStyle = `rgba(255, 255, 255, ${fadeColor})`;
                    context.fillRect(0, 0, canvas.width, canvas.height);
                }
                if (scrollTimeout <= 2000) {
                    context.fillStyle = `rgba(200, 200, 200, ${(2000 - scrollTimeout) / 1000})`;
                    context.font = `${pauseScale}px sans-serif`;
                    context.fillText(speedScale() ? speedScale() + "x" : "Paused", 0.2 * scale, canvas.height - 0.2 * scale);
                }
            };
            rfaQueue.push(tick);

            // scrolling input
            if (!perWorld) {
                canvas.addEventListener("wheel", ev => {
                    speedIncrement += ev.deltaY;
                    const oldSpeedLevel = speedLevel;
                    if (speedIncrement >= scrollThreshold) {
                        speedLevel--;
                    } else if (speedIncrement <= -scrollThreshold) {
                        speedLevel++;
                    }
                    if (oldSpeedLevel != speedLevel) {
                        speedIncrement = 0;
                        speedLevel = Math.max(0, Math.min(speeds.length - 1, speedLevel));
                        scrollTimeout = 0;
                    }
                    ev.preventDefault();
                });
            }
        }

        function hookLoad(elem) {
            let init = false;
            const canvases = elem.querySelectorAll("canvas");
            elem.addEventListener("toggle", () => {
                if (!init) {
                    canvases.forEach(initializeElem);
                    init = true;
                }
            });
        }

        function hookToggle(elem) {
            const details = Array.from(document.querySelectorAll("details." + elem.dataset.target));
            elem.addEventListener("click", () => {
                if (details.some(x => x.open)) {
                    details.forEach(x => x.open = false);
                } else {
                    details.forEach(x => x.open = true);
                }
            });
        }

        const params = new URLSearchParams(document.location.search);

        function hookSpoiler(elem) {
            if (params.get("nospoiler") !== null) {
                elem.classList.add("unspoilered");
            } else {
                const thunk = ev => {
                    if (!elem.classList.contains("unspoilered")) {
                        ev.preventDefault();
                        ev.stopImmediatePropagation();
                        elem.classList.add("unspoilered");
                    }
                    elem.removeEventListener("click", thunk);
                };
                elem.addEventListener("click", thunk);

                if (elem instanceof HTMLAnchorElement) {
                    const href = elem.getAttribute("href");
                    if (href.startsWith("#")) {
                        elem.addEventListener("click", () => document.getElementById(href.substring(1)).querySelector(".spoilered").classList.add("unspoilered"));
                    }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('details.spell-collapsible').forEach(hookLoad);
            document.querySelectorAll('a.toggle-link').forEach(hookToggle);
            document.querySelectorAll('.spoilered').forEach(hookSpoiler);

            function tick(prevTime, time) {
                const dt = time - prevTime;
                for (const q of rfaQueue) {
                    q(dt);
                }
                requestAnimationFrame(t => tick(time, t));
            }

            requestAnimationFrame(t => tick(t, t));
        });

    </script>

</head>
<body>
<div class="container" style="margin-top: 3em;">
    <blockquote>
        <h1>This is the online version of the Hexcasting documentation.</h1>
        <p>Embedded images and patterns are included, but not crafting recipes or items. There's an in-game book for
            those.</p>
        <p>Additionally, this is built from the latest code on GitHub. It may describe <b>newer</b> features that you
            may not necessarily have, even on the latest CurseForge version!</p>
        <p><b>Entries which are blurred are spoilers</b>. Click to reveal them, but be aware that they may spoil endgame
            progression. Alternatively, click <a href="?nospoiler">here</a> to get a version with all spoilers showing.
        </p>
    </blockquote>
</div>
<div class='container'><header class='jumbotron'><h1 class='book-title'>Hex Notebook</h1><p>I seem to have discovered a new method of magical arts, in which one draws patterns strange and wild onto a hexagonal grid. It fascinates me. I've decided to start a journal of my thoughts and findings.</p><p><a href='https://discord.gg/4xxHGYteWk'>Discord Server Link</a></p></header><nav><h2 id='table-of-contents' class='page-header'>Table of Contents<a href='javascript:void(0)' class='toggle-link small' data-target='toc-category'>(toggle all)</a><a href='#table-of-contents' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><details class='toc-category'><summary><a href='#greatwork' class='spoilered'>The Great Work</a></summary><ul><li><a href='#greatwork/astral_self' class='spoilered'>Astral Self</a></li></ul></details><details class='toc-category'><summary><a href='#patterns' class='spoilered'>Patterns</a></summary><ul><li><a href='#patterns/astral_utils' class='spoilered'>Astral Utilities</a></li></ul></details><details class='toc-category'><summary><a href='#patterns/great_spells' class=''>Great Spells</a></summary><ul><li><a href='#patterns/great_spells/astral_projection' class=''>Astral Projection</a></li></ul></details></nav><main class='book-body'><section id='greatwork'><div class='spoilered'><h2 class='category-title page-header'>The Great Work<a href='#greatwork' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>I have seen... so much. I have... experienced... annihilation and deconstruction and reconstruction. I have seen the atoms of the world screaming as they were inverted and subverted and demoted to energy. I have seen I have seen I have s<span class='obfuscated'>get stick bugged lmao</span></p></div><div id='greatwork/astral_self'><div class='spoilered'><h3 class='entry-title page-header'>Astral Self<a href='#greatwork/astral_self' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><p>The state of <a href='#mediaworks:patterns/great_spells/astral_projection'><span style='color: #8d6acc'>Astral Projection</span></a> is... <span style='color: #8d6acc'>TRUE BLISS</span>! In it, I can <i>hear</i> the veil thinning, I can <i>see</i> the whispers of Nature, I can <i>smell</i> colors of <span style='color: #74b3f2'>media</span> calling out to me senses jumbled must reach must attain mu<span class='obfuscated'>st remark that you're quite attentive lol</span></p><br /><p>While projecting, I can fly as I please within my range of influence and phase through any blocks. However, my astral self sees the world in black and white, its sight fading as it moves further from my body, and a thick fog occludes its sight not that far away. It cannot interact with anything and cannot be interacted with.</p><br /><p>While I visualise my astral self as a translucent copy of me, other casters can only see a flying particle cloud colored with my <a href='#items/pigments'><span style='color: #8d6acc'>pigment</span></a>, and other creatures ignore my astral self completely.</p><p>There is still one more boon: if my <a href='#mediaworks:patterns/great_spells/astral_projection'><span style='color: #8d6acc'>Astral Projection</span></a> spell captured an <span style='color: #8d6acc'>Astral Iota</span>, then whenever I press <span style='color: #8d6acc'>Right Click</span> during that projection, Nature evaluates the iota, much like when casting from a <a href='#items/hexcasting'><span style='color: #8d6acc'>Casting Item</span></a>.</p><br /><p>If Astral Projection ends peacefully, Nature gently pushes my mind back into my body. This happens if:</p><p class='fake-li'>The time allotted by the corresponding <a href='#mediaworks:patterns/great_spells/astral_projection'><span style='color: #8d6acc'>spell</span></a> runs out;</p><p class='fake-li'>I press <span style='color: #8d6acc'>E</span>.</p><br /><p>However, sometimes Astral Projection ends... not so peacefully. Nature does not take kindly to betrayal of its expectations, and throws my mind back into my body, in disarray. This happens if:</p><p class='fake-li'>My attempt to cast an Astral Iota results in a failure;</p><p class='fake-li'>My dull body is moved further than 3 blocks from the casting position;</p><p class='fake-li'>My astral self leaves my range of influence.</p><br /><p>...I've done some more research, though. It appears that, if I act carefully, - I need to be careful I MUST, I can NOT lose myself to arrogance now, - there might be a way to <a href='#patterns/great_spells/greater_sentinel'><span style='color: #8d6acc'>circumvent</span></a> the range limitation altogether.</p><br /></div></div></section><section id='patterns'><div class='spoilered'><h2 class='category-title page-header'>Patterns<a href='#patterns' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>A list of all the patterns I've discovered, as well as what they do.</p></div><div id='patterns/astral_utils'><div class='spoilered'><h3 class='entry-title page-header'>Astral Utilities<a href='#patterns/astral_utils' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/astral_utils@mediaworks:astral_pos'><h4 class='pattern-title'>Astral Locale Reflection (→ vector)<a href='#patterns/astral_utils@mediaworks:astral_pos' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='qaqqqqaq' data-start='north_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: qaqqqqaq</canvas></details><p>Returns the "eye" position vector of my astral self, similarly to how <a href='#patterns/basics@hexcasting:entity_pos/eye'><span style='color: #8d6acc'>Compass' Purification</span></a> works for my physical body. Returns <a href='#casting/influences'><span style='color: #8d6acc'>Null</span></a> if I am not projecting.</p></div><br /><div id='patterns/astral_utils@mediaworks:astral_look'><h4 class='pattern-title'>Astral Gaze Reflection (→ vector)<a href='#patterns/astral_utils@mediaworks:astral_look' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='waawaq' data-start='north_east' data-per-world=False>Your browser does not support visualizing patterns. Pattern code: waawaq</canvas></details><p>Returns the direction my astral self is looking in, similarly to how <a href='#patterns/basics@hexcasting:get_entity_look'><span style='color: #8d6acc'>Alidade's Purification</span></a> works for my physical body. Returns <a href='#casting/influences'><span style='color: #8d6acc'>Null</span></a> if I am not projecting.</p></div><br /></div></div></section><section id='patterns/great_spells'><h2 class='category-title page-header'>Great Spells<a href='#patterns/great_spells' class='permalink small'><i class='bi bi-link-45deg'></i></a></h2><p>The spells catalogued here are purported to be of legendary difficulty and power. They seem to have been recorded only sparsely (for good reason, the texts claim). It's probably just the hogwash of extinct traditionalists, though-- a pattern's a pattern. What could possibly go wrong?</p><div id='patterns/great_spells/astral_projection'><h3 class='entry-title page-header'>Astral Projection<a href='#patterns/great_spells/astral_projection' class='permalink small'><i class='bi bi-link-45deg'></i></a></h3><div id='patterns/great_spells/astral_projection@mediaworks:astral_projection'><h4 class='pattern-title'>Astral Projection (number →)<a href='#patterns/great_spells/astral_projection@mediaworks:astral_projection' class='permalink small'><i class='bi bi-link-45deg'></i></a></h4><details class='spell-collapsible'><summary class='collapse-spell'></summary><canvas class='spell-viz' width=216 height=216 data-string='qdadwewewdadeadwddaaedqdeddew' data-start='north_west' data-per-world=True>Your browser does not support visualizing patterns. Pattern code: qdadwewewdadeadwddaaedqdeddew</canvas></details><p>Finally, no longer am I confined to my mortal shell! The spell <a href='#mediaworks:greatwork/astral_self'><span style='color: #8d6acc'>projects</span></a> my mind outside of my body, granting multiple useful abilities for the specified number of seconds.</p></div><br /><p>Seeing how inert and defenseless the body becomes without a mind actively governing it, I suppose it is a boon that this spell only targets the caster.</p><p>Casting the spell costs about 2 units of <a href='#items/amethyst'><span style='color: #b0b'>Amethyst Dust</span></a> per second of duration.<br />If my <a href='#patterns/readwrite@hexcasting:local'><span style='color: #8d6acc'>ravenmind</span></a> holds any iota when I cast this spell, the iota is captured as an <span style='color: #8d6acc'>Astral Iota</span> for the entire duration of the projection.</p><br /><p>During such a massive paradigm shift, concentration is hard to maintain, so all the patterns I've drawn and iotas I've saved to my previous stack are lost.</p><p>At the same time, it seems that simply I cannot extend my remaining time while dissociated. Trying to do so leads to an <a href='#casting/mishaps'><span style='color: #8d6acc'>Entity is Immune</span></a> mishap.</p><br /></div></section></main></div>
</body>
</html>
